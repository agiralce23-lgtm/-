<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Camera + Processed + Auto ROI (Rectangle Frame)</title>
  <style>
    :root { color-scheme: light dark; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    header { padding:12px 14px; border-bottom:1px solid rgba(127,127,127,.35); }
    .wrap { max-width: 980px; margin:0 auto; padding: 0 14px 18px; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    button, select, input { font-size:14px; }
    button { padding:8px 12px; cursor:pointer; }
    .stack { display:grid; gap:12px; margin-top:12px; }
    .panel { border:1px solid rgba(127,127,127,.35); border-radius:10px; overflow:hidden; }
    .panel h2 { margin:0; padding:10px 12px; font-size:14px; border-bottom:1px solid rgba(127,127,127,.25); }
    .content { padding:10px 12px; }
    video, canvas { width:100%; height:auto; display:block; background:#000; }
    .hint { opacity:.8; font-size:12px; line-height:1.4; padding: 8px 14px 0; }
    .err  { color:#d33; white-space:pre-wrap; font-size:12px; padding: 6px 14px 0; }
    .tiny { font-size:12px; opacity:.85; }
    .slider { display:flex; align-items:center; gap:8px; }
    .slider label { min-width: 86px; }
    .slider input[type="range"] { width: 220px; }
    .pill { padding: 2px 8px; border: 1px solid rgba(127,127,127,.4); border-radius: 999px; }
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <div class="row">
        <button id="btnStart">カメラ開始</button>
        <button id="btnStop" disabled>停止</button>

        <label>カメラ:
          <select id="selDevice"></select>
        </label>

        <label>表示:
          <select id="selMode">
            <option value="gray">グレースケール</option>
            <option value="thresh">二値化</option>
            <option value="edges" selected>エッジ</option>
          </select>
        </label>

        <span class="slider">
          <label for="rngProcW">処理解像度</label>
          <input id="rngProcW" type="range" min="320" max="960" step="10" value="640">
          <span class="tiny" id="lblProcW">640</span>
        </span>

        <span class="slider">
          <label for="rngEdge">エッジ閾値</label>
          <input id="rngEdge" type="range" min="0" max="255" value="70">
          <span class="tiny" id="lblEdge">70</span>
        </span>

        <span class="slider">
          <label for="rngLine">線の強さ</label>
          <input id="rngLine" type="range" min="10" max="95" value="60">
          <span class="tiny" id="lblLine">0.60</span>
        </span>

        <span class="slider">
          <label for="rngSmooth">平滑化</label>
          <input id="rngSmooth" type="range" min="0" max="100" value="25">
          <span class="tiny" id="lblSmooth">0.25</span>
        </span>

        <label>
          <input type="checkbox" id="chkAutoThresh" checked>
          自動しきい値(Otsu)
        </label>

        <span class="slider">
          <label for="rngThresh">しきい値</label>
          <input id="rngThresh" type="range" min="0" max="255" value="140">
          <span class="tiny" id="lblThresh">140</span>
        </span>

        <label>
          <input type="checkbox" id="chkMirror" checked>
          ミラー
        </label>

        <span class="tiny pill" id="roiText">ROI: -</span>
        <span class="tiny" id="status">未開始</span>
      </div>

      <div class="hint">
        下段に処理画像を常時表示しつつ、四角枠（フレーム）を推定してROIを赤枠表示します。<br>
        ※カメラは “https” か “localhost” で開くのが確実（file:// 直開きは失敗しがち）。
      </div>
      <div class="err" id="err"></div>
    </div>
  </header>

  <main class="wrap">
    <div class="stack">
      <section class="panel">
        <h2>撮影画面（上）</h2>
        <div class="content">
          <video id="video" playsinline autoplay muted></video>
        </div>
      </section>

      <section class="panel">
        <h2>処理後（下）＋ 自動ROI（赤枠）</h2>
        <div class="content">
          <canvas id="processed"></canvas>
        </div>
      </section>

      <section class="panel">
        <h2>ROI切り出し（確認用）</h2>
        <div class="content">
          <canvas id="roi"></canvas>
        </div>
      </section>
    </div>
  </main>

  <script>
    const video = document.getElementById('video');
    const outCanvas = document.getElementById('processed');
    const outCtx = outCanvas.getContext('2d', { willReadFrequently: true });

    const roiCanvas = document.getElementById('roi');
    const roiCtx = roiCanvas.getContext('2d', { willReadFrequently: true });

    // offscreen for processing
    const procCanvas = document.createElement('canvas');
    const procCtx = procCanvas.getContext('2d', { willReadFrequently: true });

    const btnStart = document.getElementById('btnStart');
    const btnStop  = document.getElementById('btnStop');
    const selDevice = document.getElementById('selDevice');
    const selMode   = document.getElementById('selMode');

    const rngProcW  = document.getElementById('rngProcW');
    const lblProcW  = document.getElementById('lblProcW');

    const rngEdge   = document.getElementById('rngEdge');
    const lblEdge   = document.getElementById('lblEdge');

    const rngLine   = document.getElementById('rngLine');
    const lblLine   = document.getElementById('lblLine');

    const rngSmooth = document.getElementById('rngSmooth');
    const lblSmooth = document.getElementById('lblSmooth');

    const chkAutoThresh = document.getElementById('chkAutoThresh');
    const rngThresh = document.getElementById('rngThresh');
    const lblThresh = document.getElementById('lblThresh');

    const chkMirror = document.getElementById('chkMirror');

    const roiText = document.getElementById('roiText');
    const statusEl = document.getElementById('status');
    const errEl = document.getElementById('err');

    let stream = null;
    let rafId = 0;

    // current ROI (smoothed)
    let roi = null; // {x,y,w,h} in processing canvas coords
    let roiConfidence = 0; // 0..1

    function setStatus(t){ statusEl.textContent = t; }
    function setError(e){ errEl.textContent = e ? String(e) : ''; }

    function applyMirror() {
      const on = chkMirror.checked;
      video.style.transform = on ? 'scaleX(-1)' : 'none';
      outCanvas.style.transform = on ? 'scaleX(-1)' : 'none';
      roiCanvas.style.transform = on ? 'scaleX(-1)' : 'none';
    }
    chkMirror.addEventListener('change', applyMirror);
    applyMirror();

    function bindSlider(sl, lab, fmt = (v)=>v) {
      const update = () => lab.textContent = fmt(sl.value);
      sl.addEventListener('input', update);
      update();
    }
    bindSlider(rngProcW, lblProcW, v => v);
    bindSlider(rngEdge,  lblEdge,  v => v);
    bindSlider(rngLine,  lblLine,  v => (parseInt(v,10)/100).toFixed(2));
    bindSlider(rngSmooth,lblSmooth,v => (parseInt(v,10)/100).toFixed(2));
    bindSlider(rngThresh,lblThresh,v => v);

    rngThresh.addEventListener('input', () => { chkAutoThresh.checked = false; });

    async function listDevices() {
      selDevice.innerHTML = '';
      const devices = await navigator.mediaDevices.enumerateDevices();
      const cams = devices.filter(d => d.kind === 'videoinput');
      cams.forEach((d, i) => {
        const opt = document.createElement('option');
        opt.value = d.deviceId;
        opt.textContent = d.label || `Camera ${i+1}`;
        selDevice.appendChild(opt);
      });
    }

    function stopStream() {
      if (rafId) cancelAnimationFrame(rafId);
      rafId = 0;

      if (stream) {
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }
      video.srcObject = null;
      setStatus('停止');
      btnStop.disabled = true;
      btnStart.disabled = false;
    }

    // Otsu threshold (gray: Uint8ClampedArray length w*h)
    function otsuThreshold(gray) {
      const hist = new Uint32Array(256);
      for (let i = 0; i < gray.length; i++) hist[gray[i]]++;

      const total = gray.length;
      let sum = 0;
      for (let t = 0; t < 256; t++) sum += t * hist[t];

      let sumB = 0, wB = 0;
      let varMax = -1;
      let threshold = 128;

      for (let t = 0; t < 256; t++) {
        wB += hist[t];
        if (wB === 0) continue;
        const wF = total - wB;
        if (wF === 0) break;

        sumB += t * hist[t];
        const mB = sumB / wB;
        const mF = (sum - sumB) / wF;

        const varBetween = wB * wF * (mB - mF) * (mB - mF);
        if (varBetween > varMax) {
          varMax = varBetween;
          threshold = t;
        }
      }
      return threshold;
    }

    function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
    function lerp(a,b,t){ return a + (b-a)*t; }

    // detect rectangle-like frame from binary edge mask by row/col projection
    function detectFrameFromEdges(edgeMask, w, h) {
      // edgeMask: Uint8Array (0 or 1), length w*h
      const rowSum = new Uint32Array(h);
      const colSum = new Uint32Array(w);

      for (let y = 0; y < h; y++) {
        let s = 0;
        const base = y * w;
        for (let x = 0; x < w; x++) {
          const v = edgeMask[base + x];
          s += v;
          colSum[x] += v;
        }
        rowSum[y] = s;
      }

      // find max row/col strengths
      let maxRow = 0, maxCol = 0;
      for (let y = 0; y < h; y++) if (rowSum[y] > maxRow) maxRow = rowSum[y];
      for (let x = 0; x < w; x++) if (colSum[x] > maxCol) maxCol = colSum[x];

      // If not strong enough, fail
      if (maxRow < w * 0.08 || maxCol < h * 0.08) return null;

      const ratio = parseInt(rngLine.value, 10) / 100; // 0.10..0.95
      const thrRow = Math.max(3, Math.floor(maxRow * ratio));
      const thrCol = Math.max(3, Math.floor(maxCol * ratio));

      let top = -1, bottom = -1, left = -1, right = -1;

      // find top
      for (let y = 0; y < h; y++) {
        if (rowSum[y] >= thrRow) { top = y; break; }
      }
      // find bottom
      for (let y = h - 1; y >= 0; y--) {
        if (rowSum[y] >= thrRow) { bottom = y; break; }
      }
      // left
      for (let x = 0; x < w; x++) {
        if (colSum[x] >= thrCol) { left = x; break; }
      }
      // right
      for (let x = w - 1; x >= 0; x--) {
        if (colSum[x] >= thrCol) { right = x; break; }
      }

      if (top < 0 || bottom < 0 || left < 0 || right < 0) return null;

      // expand a little (edge line thickness)
      const pad = 2;
      top = clamp(top - pad, 0, h - 1);
      bottom = clamp(bottom + pad, 0, h - 1);
      left = clamp(left - pad, 0, w - 1);
      right = clamp(right + pad, 0, w - 1);

      const rw = right - left + 1;
      const rh = bottom - top + 1;

      // sanity checks (avoid whole-screen or tiny picks)
      if (rw < w * 0.18 || rw > w * 0.98) return null;
      if (rh < h * 0.10 || rh > h * 0.98) return null;

      // confidence: how strong the chosen borders are vs max
      const confRow = Math.min(rowSum[top] / maxRow, rowSum[bottom] / maxRow);
      const confCol = Math.min(colSum[left] / maxCol, colSum[right] / maxCol);
      const conf = Math.max(0, Math.min(1, (confRow + confCol) / 2));

      return { x: left, y: top, w: rw, h: rh, conf };
    }

    function fallbackCenterROI(w, h) {
      // a reasonable default until detection locks
      const rw = Math.round(w * 0.55);
      const rh = Math.round(h * 0.22);
      const x = Math.round((w - rw) / 2);
      const y = Math.round((h - rh) / 2);
      return { x, y, w: rw, h: rh, conf: 0 };
    }

    function renderLoop() {
      const vw = video.videoWidth | 0;
      const vh = video.videoHeight | 0;
      if (vw > 0 && vh > 0) {
        const targetW = parseInt(rngProcW.value, 10) || 640;
        const scale = targetW / vw;
        const pw = Math.max(200, Math.round(vw * scale));
        const ph = Math.max(150, Math.round(vh * scale));

        if (procCanvas.width !== pw || procCanvas.height !== ph) {
          procCanvas.width = pw;
          procCanvas.height = ph;
        }
        if (outCanvas.width !== pw || outCanvas.height !== ph) {
          outCanvas.width = pw;
          outCanvas.height = ph;
        }

        // Draw frame to offscreen
        procCtx.drawImage(video, 0, 0, pw, ph);
        const img = procCtx.getImageData(0, 0, pw, ph);
        const data = img.data;

        // Grayscale
        const gray = new Uint8ClampedArray(pw * ph);
        for (let i = 0, p = 0; i < data.length; i += 4, p++) {
          const r = data[i], g = data[i+1], b = data[i+2];
          gray[p] = (0.299*r + 0.587*g + 0.114*b) | 0;
        }

        // Threshold (for display mode or later use)
        let t = parseInt(rngThresh.value, 10) | 0;
        if (chkAutoThresh.checked) {
          t = otsuThreshold(gray);
          rngThresh.value = t;
          lblThresh.textContent = t;
        }

        const mode = selMode.value;

        // Edge mask (binary) for ROI detection
        const edgeT = parseInt(rngEdge.value, 10) | 0;
        const edgeMask = new Uint8Array(pw * ph);

        // Sobel on gray → edgeMask
        // (skip border pixels)
        for (let y = 1; y < ph - 1; y++) {
          const y0 = (y - 1) * pw;
          const y1 = y * pw;
          const y2 = (y + 1) * pw;
          for (let x = 1; x < pw - 1; x++) {
            const p00 = gray[y0 + (x - 1)], p01 = gray[y0 + x],     p02 = gray[y0 + (x + 1)];
            const p10 = gray[y1 + (x - 1)], /*p11*/                   p12 = gray[y1 + (x + 1)];
            const p20 = gray[y2 + (x - 1)], p21 = gray[y2 + x],     p22 = gray[y2 + (x + 1)];

            const gx = (-1*p00) + (1*p02) + (-2*p10) + (2*p12) + (-1*p20) + (1*p22);
            const gy = ( 1*p00) + (2*p01) + (1*p02) + (-1*p20) + (-2*p21) + (-1*p22);
            let mag = Math.abs(gx) + Math.abs(gy);
            if (mag > 255) mag = 255;
            edgeMask[y1 + x] = (mag >= edgeT) ? 1 : 0;
          }
        }

        // Display image (gray / thresh / edges)
        if (mode === 'gray') {
          for (let i = 0, p = 0; i < data.length; i += 4, p++) {
            const yv = gray[p];
            data[i] = data[i+1] = data[i+2] = yv;
          }
          outCtx.putImageData(img, 0, 0);
        } else if (mode === 'thresh') {
          for (let i = 0, p = 0; i < data.length; i += 4, p++) {
            const v = gray[p] >= t ? 255 : 0;
            data[i] = data[i+1] = data[i+2] = v;
          }
          outCtx.putImageData(img, 0, 0);
        } else { // edges
          for (let i = 0, p = 0; i < data.length; i += 4, p++) {
            const v = edgeMask[p] ? 255 : 0;
            data[i] = data[i+1] = data[i+2] = v;
          }
          outCtx.putImageData(img, 0, 0);
        }

        // --- Auto ROI detect ---
        let detected = detectFrameFromEdges(edgeMask, pw, ph);

        // fallback if nothing detected
        if (!detected) detected = fallbackCenterROI(pw, ph);

        // smooth ROI to avoid jitter
        const smooth = parseInt(rngSmooth.value, 10) / 100; // 0..1
        if (!roi) {
          roi = { x: detected.x, y: detected.y, w: detected.w, h: detected.h };
          roiConfidence = detected.conf || 0;
        } else {
          roi.x = Math.round(lerp(roi.x, detected.x, smooth));
          roi.y = Math.round(lerp(roi.y, detected.y, smooth));
          roi.w = Math.round(lerp(roi.w, detected.w, smooth));
          roi.h = Math.round(lerp(roi.h, detected.h, smooth));
          roiConfidence = lerp(roiConfidence, (detected.conf || 0), smooth);
        }

        // clamp ROI within bounds
        roi.x = clamp(roi.x, 0, pw - 1);
        roi.y = clamp(roi.y, 0, ph - 1);
        roi.w = clamp(roi.w, 10, pw - roi.x);
        roi.h = clamp(roi.h, 10, ph - roi.y);

        // draw ROI rectangle on output
        outCtx.save();
        outCtx.lineWidth = Math.max(2, Math.round(pw / 320));
        outCtx.strokeStyle = 'red';
        outCtx.strokeRect(roi.x + 0.5, roi.y + 0.5, roi.w, roi.h);
        outCtx.restore();

        // ROI text
        roiText.textContent = `ROI: x=${roi.x}, y=${roi.y}, w=${roi.w}, h=${roi.h}  conf=${roiConfidence.toFixed(2)}`;

        // crop ROI preview
        const rw = Math.max(1, roi.w);
        const rh = Math.max(1, roi.h);
        const maxPreviewW = 900;
        const scaleRoi = Math.min(1, maxPreviewW / rw);
        roiCanvas.width = Math.round(rw * scaleRoi);
        roiCanvas.height = Math.round(rh * scaleRoi);

        // draw from procCanvas (original frame) to ROI preview
        roiCtx.imageSmoothingEnabled = false;
        roiCtx.clearRect(0,0,roiCanvas.width, roiCanvas.height);
        roiCtx.drawImage(procCanvas, roi.x, roi.y, rw, rh, 0, 0, roiCanvas.width, roiCanvas.height);
      }

      rafId = requestAnimationFrame(renderLoop);
    }

    async function startCamera(deviceId) {
      setError('');
      stopStream();

      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        throw new Error('getUserMedia 非対応。Chrome/Edge の新しめで試してください。');
      }

      const constraints = {
        audio: false,
        video: {
          deviceId: deviceId ? { exact: deviceId } : undefined,
          width:  { ideal: 1280 },
          height: { ideal: 720 }
        }
      };

      stream = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject = stream;

      await new Promise(resolve => {
        if (video.readyState >= 1) return resolve();
        video.onloadedmetadata = () => resolve();
      });
      await video.play();

      setStatus('稼働中');
      btnStop.disabled = false;
      btnStart.disabled = true;

      // after permission, labels become available
      await listDevices();
      if (deviceId) selDevice.value = deviceId;

      renderLoop();
    }

    btnStart.addEventListener('click', async () => {
      try {
        setStatus('起動中...');
        await startCamera(selDevice.value || null);
      } catch (e) {
        setStatus('開始失敗');
        setError(e);
        stopStream();
      }
    });

    btnStop.addEventListener('click', () => stopStream());

    selDevice.addEventListener('change', async () => {
      if (!stream) return;
      try {
        setStatus('切替中...');
        await startCamera(selDevice.value);
      } catch (e) {
        setStatus('切替失敗');
        setError(e);
        stopStream();
      }
    });

    // init
    (async () => {
      try { await listDevices(); } catch (e) { /* ignore */ }
    })();
  </script>
</body>
</html>
