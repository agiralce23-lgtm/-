<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>7seg - Processed + Auto ROI (Frame -> Digits)</title>
  <style>
    :root { color-scheme: light dark; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    header { padding:12px 14px; border-bottom:1px solid rgba(127,127,127,.35); }
    .wrap { max-width: 980px; margin:0 auto; padding: 0 14px 18px; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    button, select, input { font-size:14px; }
    button { padding:8px 12px; cursor:pointer; }
    .stack { display:grid; gap:12px; margin-top:12px; }
    .panel { border:1px solid rgba(127,127,127,.35); border-radius:10px; overflow:hidden; }
    .panel h2 { margin:0; padding:10px 12px; font-size:14px; border-bottom:1px solid rgba(127,127,127,.25); }
    .content { padding:10px 12px; }
    video, canvas { width:100%; height:auto; display:block; background:#000; }
    .hint { opacity:.8; font-size:12px; line-height:1.4; padding: 8px 14px 0; }
    .err  { color:#d33; white-space:pre-wrap; font-size:12px; padding: 6px 14px 0; }
    .tiny { font-size:12px; opacity:.85; }
    .slider { display:flex; align-items:center; gap:8px; }
    .slider label { min-width: 86px; }
    .slider input[type="range"] { width: 220px; }
    .pill { padding: 2px 8px; border: 1px solid rgba(127,127,127,.4); border-radius: 999px; }
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <div class="row">
        <button id="btnStart">カメラ開始</button>
        <button id="btnStop" disabled>停止</button>

        <label>カメラ:
          <select id="selDevice"></select>
        </label>

        <label>表示:
          <select id="selMode">
            <option value="gray">グレースケール</option>
            <option value="thresh">二値化</option>
            <option value="edges" selected>エッジ</option>
          </select>
        </label>

        <span class="slider">
          <label for="rngProcW">処理解像度</label>
          <input id="rngProcW" type="range" min="320" max="960" step="10" value="640">
          <span class="tiny" id="lblProcW">640</span>
        </span>

        <span class="slider">
          <label for="rngEdge">エッジ閾値</label>
          <input id="rngEdge" type="range" min="0" max="255" value="60">
          <span class="tiny" id="lblEdge">60</span>
        </span>

        <span class="slider">
          <label for="rngLine">線の強さ</label>
          <input id="rngLine" type="range" min="10" max="95" value="50">
          <span class="tiny" id="lblLine">0.50</span>
        </span>

        <span class="slider">
          <label for="rngSmooth">平滑化</label>
          <input id="rngSmooth" type="range" min="0" max="100" value="30">
          <span class="tiny" id="lblSmooth">0.30</span>
        </span>

        <label>
          <input type="checkbox" id="chkPreferDigits" checked>
          ROIを数字帯に絞る
        </label>

        <label>
          <input type="checkbox" id="chkMirror" checked>
          ミラー
        </label>

        <span class="tiny pill" id="roiText">ROI: -</span>
        <span class="tiny" id="status">未開始</span>
      </div>

      <div class="hint">
        水色=外枠候補 / 赤=最終ROI（数字帯）<br>
        下枠が別の線を掴んでも、数字帯で再推定するので最終ROIが安定します。
      </div>
      <div class="err" id="err"></div>
    </div>
  </header>

  <main class="wrap">
    <div class="stack">
      <section class="panel">
        <h2>撮影画面（上）</h2>
        <div class="content">
          <video id="video" playsinline autoplay muted></video>
        </div>
      </section>

      <section class="panel">
        <h2>処理後（下）＋ 自動ROI</h2>
        <div class="content">
          <canvas id="processed"></canvas>
        </div>
      </section>

      <section class="panel">
        <h2>ROI切り出し（確認用）</h2>
        <div class="content">
          <canvas id="roi"></canvas>
        </div>
      </section>
    </div>
  </main>

  <script>
    const video = document.getElementById('video');
    const outCanvas = document.getElementById('processed');
    const outCtx = outCanvas.getContext('2d', { willReadFrequently: true });

    const roiCanvas = document.getElementById('roi');
    const roiCtx = roiCanvas.getContext('2d', { willReadFrequently: true });

    const procCanvas = document.createElement('canvas');
    const procCtx = procCanvas.getContext('2d', { willReadFrequently: true });

    const btnStart = document.getElementById('btnStart');
    const btnStop  = document.getElementById('btnStop');
    const selDevice = document.getElementById('selDevice');
    const selMode   = document.getElementById('selMode');

    const rngProcW  = document.getElementById('rngProcW');
    const lblProcW  = document.getElementById('lblProcW');

    const rngEdge   = document.getElementById('rngEdge');
    const lblEdge   = document.getElementById('lblEdge');

    const rngLine   = document.getElementById('rngLine');
    const lblLine   = document.getElementById('lblLine');

    const rngSmooth = document.getElementById('rngSmooth');
    const lblSmooth = document.getElementById('lblSmooth');

    const chkPreferDigits = document.getElementById('chkPreferDigits');
    const chkMirror = document.getElementById('chkMirror');

    const roiText = document.getElementById('roiText');
    const statusEl = document.getElementById('status');
    const errEl = document.getElementById('err');

    let stream = null;
    let rafId = 0;

    // smoothed final ROI (digits ROI)
    let roi = null; // {x,y,w,h} in processing canvas coords
    let roiConf = 0;

    function setStatus(t){ statusEl.textContent = t; }
    function setError(e){ errEl.textContent = e ? String(e) : ''; }

    function applyMirror() {
      const on = chkMirror.checked;
      video.style.transform = on ? 'scaleX(-1)' : 'none';
      outCanvas.style.transform = on ? 'scaleX(-1)' : 'none';
      roiCanvas.style.transform = on ? 'scaleX(-1)' : 'none';
    }
    chkMirror.addEventListener('change', applyMirror);
    applyMirror();

    function bindSlider(sl, lab, fmt = (v)=>v) {
      const update = () => lab.textContent = fmt(sl.value);
      sl.addEventListener('input', update);
      update();
    }
    bindSlider(rngProcW, lblProcW, v => v);
    bindSlider(rngEdge,  lblEdge,  v => v);
    bindSlider(rngLine,  lblLine,  v => (parseInt(v,10)/100).toFixed(2));
    bindSlider(rngSmooth,lblSmooth,v => (parseInt(v,10)/100).toFixed(2));

    async function listDevices() {
      selDevice.innerHTML = '';
      const devices = await navigator.mediaDevices.enumerateDevices();
      const cams = devices.filter(d => d.kind === 'videoinput');
      cams.forEach((d, i) => {
        const opt = document.createElement('option');
        opt.value = d.deviceId;
        opt.textContent = d.label || `Camera ${i+1}`;
        selDevice.appendChild(opt);
      });
    }

    function stopStream() {
      if (rafId) cancelAnimationFrame(rafId);
      rafId = 0;

      if (stream) {
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }
      video.srcObject = null;
      setStatus('停止');
      btnStop.disabled = true;
      btnStart.disabled = false;
    }

    function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
    function lerp(a,b,t){ return a + (b-a)*t; }

    // ====== 1) 外枠（フレーム）検出：下側を取り過ぎないように “高さ制限” を入れる ======
    function detectFrameFromEdges(edgeMask, w, h) {
      const rowSum = new Uint32Array(h);
      const colSum = new Uint32Array(w);

      for (let y = 0; y < h; y++) {
        let s = 0;
        const base = y * w;
        for (let x = 0; x < w; x++) {
          const v = edgeMask[base + x];
          s += v;
          colSum[x] += v;
        }
        rowSum[y] = s;
      }

      // 重要：ボタン側の強い線を下枠にしないため、候補の高さを制限
      const TOP_MAX_Y   = Math.floor(h * 0.70);
      const MIN_H       = Math.floor(h * 0.10);
      const MAX_H       = Math.floor(h * 0.40); // ←ここで下に伸び過ぎを抑止（効く）

      let maxRow = 0, maxCol = 0;
      for (let y = 0; y < TOP_MAX_Y; y++) if (rowSum[y] > maxRow) maxRow = rowSum[y];
      for (let x = 0; x < w; x++) if (colSum[x] > maxCol) maxCol = colSum[x];

      if (maxRow < w * 0.05 || maxCol < h * 0.05) return null;

      const ratio = parseInt(rngLine.value, 10) / 100;
      const thrRow = Math.max(3, Math.floor(maxRow * ratio));
      const thrCol = Math.max(3, Math.floor(maxCol * ratio));

      // top：上から最初に「線っぽい」行
      let top = -1;
      for (let y = 0; y < TOP_MAX_Y; y++) {
        if (rowSum[y] >= thrRow) { top = y; break; }
      }
      if (top < 0) return null;

      // bottom： top + [MIN_H..MAX_H] の範囲で “一番強い行” を選ぶ（←これが下枠誤検出に効く）
      const b0 = clamp(top + MIN_H, 0, h - 2);
      const b1 = clamp(top + MAX_H, 0, h - 2);
      let bottom = -1;
      let best = 0;
      for (let y = b0; y <= b1; y++) {
        const v = rowSum[y];
        if (v > best) { best = v; bottom = y; }
      }
      if (bottom < 0 || best < thrRow) return null;

      // left/right：中央寄りで探す（外装の輪郭を拾いにくくする）
      const X_MIN = Math.floor(w * 0.03);
      const X_MAX = Math.floor(w * 0.97);

      let left = -1, right = -1;
      for (let x = X_MIN; x < X_MAX; x++) {
        if (colSum[x] >= thrCol) { left = x; break; }
      }
      for (let x = X_MAX; x >= X_MIN; x--) {
        if (colSum[x] >= thrCol) { right = x; break; }
      }
      if (left < 0 || right < 0) return null;

      const pad = 2;
      top = clamp(top - pad, 0, h - 1);
      bottom = clamp(bottom + pad, 0, h - 1);
      left = clamp(left - pad, 0, w - 1);
      right = clamp(right + pad, 0, w - 1);

      const rw = right - left + 1;
      const rh = bottom - top + 1;

      // 体重計の窓は横長
      const ar = rw / Math.max(1, rh);
      if (rw < w * 0.20 || rw > w * 0.98) return null;
      if (rh < h * 0.08 || rh > h * 0.55) return null;
      if (ar < 2.0 || ar > 7.0) return null;

      const confRow = Math.min(rowSum[top] / maxRow, rowSum[bottom] / maxRow);
      const confCol = Math.min(colSum[left] / maxCol, colSum[right] / maxCol);
      const conf = Math.max(0, Math.min(1, (confRow + confCol) / 2));

      return { x:left, y:top, w:rw, h:rh, conf };
    }

    // ====== 2) フレーム内から “数字帯” を再推定（ここがピタッとさせる肝） ======
    function refineToDigits(edgeMask, W, H, frame) {
      if (!frame) return null;
      const fx = frame.x, fy = frame.y, fw = frame.w, fh = frame.h;

      // 下側（ボタン側）の影響を切る：フレーム上側70%だけ見る
      const yEnd = clamp(fy + Math.floor(fh * 0.70), 0, H-1);

      // 行方向プロファイル（フレーム内）
      const rows = new Uint32Array(yEnd - fy + 1);
      let maxR = 0;
      for (let y = fy; y <= yEnd; y++) {
        let s = 0;
        const base = y * W;
        for (let x = fx; x < fx + fw; x++) s += edgeMask[base + x];
        rows[y - fy] = s;
        if (s > maxR) maxR = s;
      }
      if (maxR < fw * 0.03) return null;

      // 数字帯の上下を決める（最大の35%を超える行が続く範囲）
      const thr = Math.max(3, Math.floor(maxR * 0.35));
      let top = -1, bottom = -1;
      for (let i = 0; i < rows.length; i++) { if (rows[i] >= thr) { top = i; break; } }
      for (let i = rows.length - 1; i >= 0; i--) { if (rows[i] >= thr) { bottom = i; break; } }
      if (top < 0 || bottom < 0 || bottom - top < 10) return null;

      // 列方向（数字帯の範囲だけ）
      const y0 = fy + top;
      const y1 = fy + bottom;
      const cols = new Uint32Array(fw);
      let maxC = 0;
      for (let x = 0; x < fw; x++) {
        let s = 0;
        for (let y = y0; y <= y1; y++) s += edgeMask[y * W + (fx + x)];
        cols[x] = s;
        if (s > maxC) maxC = s;
      }
      if (maxC < (y1 - y0) * 0.03) return null;

      const thrC = Math.max(3, Math.floor(maxC * 0.25));
      let left = -1, right = -1;
      for (let i = 0; i < cols.length; i++) { if (cols[i] >= thrC) { left = i; break; } }
      for (let i = cols.length - 1; i >= 0; i--) { if (cols[i] >= thrC) { right = i; break; } }
      if (left < 0 || right < 0 || right - left < 20) return null;

      // パディング（数字を取りこぼさない）
      const padX = Math.max(6, Math.floor(fw * 0.03));
      const padY = Math.max(6, Math.floor((y1 - y0) * 0.15));

      const rx = clamp(fx + left - padX, 0, W-1);
      const ry = clamp(y0 - padY, 0, H-1);
      const rr = clamp(fx + right + padX, 0, W-1);
      const rb = clamp(y1 + padY, 0, H-1);

      const rw = rr - rx + 1;
      const rh = rb - ry + 1;

      // 数字帯は横長（ただしフレームよりは小さい）
      const ar = rw / Math.max(1, rh);
      if (rw < W * 0.18 || rh < H * 0.05) return null;
      if (ar < 2.2 || ar > 12.0) return null;

      // conf（ざっくり）
      const conf = Math.max(0, Math.min(1, (maxR / fw) * 0.8));

      return { x:rx, y:ry, w:rw, h:rh, conf };
    }

    function fallbackROI(w, h) {
      // 上寄りセンター（数字窓が上にある前提）
      const rw = Math.round(w * 0.60);
      const rh = Math.round(h * 0.18);
      const x = Math.round((w - rw) / 2);
      const y = Math.round(h * 0.32);
      return { x, y, w: rw, h: rh, conf: 0 };
    }

    function drawRect(ctx, r, color) {
      if (!r) return;
      ctx.save();
      ctx.lineWidth = Math.max(2, Math.round(outCanvas.width / 320));
      ctx.strokeStyle = color;
      ctx.strokeRect(r.x + 0.5, r.y + 0.5, r.w, r.h);
      ctx.restore();
    }

    function renderLoop() {
      const vw = video.videoWidth | 0;
      const vh = video.videoHeight | 0;

      if (vw > 0 && vh > 0) {
        const targetW = parseInt(rngProcW.value, 10) || 640;
        const scale = targetW / vw;
        const pw = Math.max(200, Math.round(vw * scale));
        const ph = Math.max(150, Math.round(vh * scale));

        if (procCanvas.width !== pw || procCanvas.height !== ph) {
          procCanvas.width = pw;
          procCanvas.height = ph;
        }
        if (outCanvas.width !== pw || outCanvas.height !== ph) {
          outCanvas.width = pw;
          outCanvas.height = ph;
        }

        // draw video -> offscreen
        procCtx.drawImage(video, 0, 0, pw, ph);
        const img = procCtx.getImageData(0, 0, pw, ph);
        const data = img.data;

        // grayscale
        const gray = new Uint8ClampedArray(pw * ph);
        for (let i = 0, p = 0; i < data.length; i += 4, p++) {
          const r = data[i], g = data[i+1], b = data[i+2];
          gray[p] = (0.299*r + 0.587*g + 0.114*b) | 0;
        }

        // edges -> edgeMask
        const edgeT = parseInt(rngEdge.value, 10) | 0;
        const edgeMask = new Uint8Array(pw * ph);

        for (let y = 1; y < ph - 1; y++) {
          const y0 = (y - 1) * pw;
          const y1 = y * pw;
          const y2 = (y + 1) * pw;
          for (let x = 1; x < pw - 1; x++) {
            const p00 = gray[y0 + (x - 1)], p01 = gray[y0 + x],     p02 = gray[y0 + (x + 1)];
            const p10 = gray[y1 + (x - 1)],                         p12 = gray[y1 + (x + 1)];
            const p20 = gray[y2 + (x - 1)], p21 = gray[y2 + x],     p22 = gray[y2 + (x + 1)];

            const gx = (-1*p00) + (1*p02) + (-2*p10) + (2*p12) + (-1*p20) + (1*p22);
            const gy = ( 1*p00) + (2*p01) + (1*p02) + (-1*p20) + (-2*p21) + (-1*p22);

            let mag = Math.abs(gx) + Math.abs(gy);
            if (mag > 255) mag = 255;
            edgeMask[y1 + x] = (mag >= edgeT) ? 1 : 0;
          }
        }

        // show processed
        const mode = selMode.value;
        if (mode === 'gray') {
          for (let i = 0, p = 0; i < data.length; i += 4, p++) {
            const yv = gray[p];
            data[i] = data[i+1] = data[i+2] = yv;
          }
        } else if (mode === 'thresh') {
          // 簡易：固定しきい値（必要ならOtsuを戻してもOK）
          const t = 140;
          for (let i = 0, p = 0; i < data.length; i += 4, p++) {
            const v = gray[p] >= t ? 255 : 0;
            data[i] = data[i+1] = data[i+2] = v;
          }
        } else { // edges
          for (let i = 0, p = 0; i < data.length; i += 4, p++) {
            const v = edgeMask[p] ? 255 : 0;
            data[i] = data[i+1] = data[i+2] = v;
          }
        }
        outCtx.putImageData(img, 0, 0);

        // ----- ROI detect -----
        const frame = detectFrameFromEdges(edgeMask, pw, ph);
        const digits = (chkPreferDigits.checked && frame) ? refineToDigits(edgeMask, pw, ph, frame) : null;
        const detected = digits || frame || fallbackROI(pw, ph);

        // smooth final ROI
        const smooth = parseInt(rngSmooth.value, 10) / 100;
        if (!roi) {
          roi = { x: detected.x, y: detected.y, w: detected.w, h: detected.h };
          roiConf = detected.conf || 0;
        } else {
          roi.x = Math.round(lerp(roi.x, detected.x, smooth));
          roi.y = Math.round(lerp(roi.y, detected.y, smooth));
          roi.w = Math.round(lerp(roi.w, detected.w, smooth));
          roi.h = Math.round(lerp(roi.h, detected.h, smooth));
          roiConf = lerp(roiConf, (detected.conf || 0), smooth);
        }

        // clamp
        roi.x = clamp(roi.x, 0, pw - 2);
        roi.y = clamp(roi.y, 0, ph - 2);
        roi.w = clamp(roi.w, 20, pw - roi.x);
        roi.h = clamp(roi.h, 20, ph - roi.y);

        // draw overlays
        // frame(水色) / digits(赤) / final ROI(赤太め)
        if (frame) drawRect(outCtx, frame, 'cyan');
        if (digits) drawRect(outCtx, digits, 'red');

        outCtx.save();
        outCtx.lineWidth = Math.max(3, Math.round(pw / 240));
        outCtx.strokeStyle = 'red';
        outCtx.strokeRect(roi.x + 0.5, roi.y + 0.5, roi.w, roi.h);
        outCtx.restore();

        roiText.textContent =
          `ROI: x=${roi.x}, y=${roi.y}, w=${roi.w}, h=${roi.h}  conf=${roiConf.toFixed(2)}`
          + (frame ? ` / frame conf=${(frame.conf||0).toFixed(2)}` : '');

        // crop ROI preview (from original procCanvas)
        const rw = roi.w, rh = roi.h;
        const maxPreviewW = 900;
        const s = Math.min(1, maxPreviewW / rw);
        roiCanvas.width = Math.round(rw * s);
        roiCanvas.height = Math.round(rh * s);
        roiCtx.imageSmoothingEnabled = false;
        roiCtx.clearRect(0,0,roiCanvas.width, roiCanvas.height);
        roiCtx.drawImage(procCanvas, roi.x, roi.y, rw, rh, 0, 0, roiCanvas.width, roiCanvas.height);
      }

      rafId = requestAnimationFrame(renderLoop);
    }

    async function startCamera(deviceId) {
      setError('');
      stopStream();

      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        throw new Error('getUserMedia 非対応。Chrome/Edge の新しめで試してください。');
      }

      const constraints = {
        audio: false,
        video: {
          deviceId: deviceId ? { exact: deviceId } : undefined,
          width:  { ideal: 1280 },
          height: { ideal: 720 }
        }
      };

      stream = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject = stream;

      await new Promise(resolve => {
        if (video.readyState >= 1) return resolve();
        video.onloadedmetadata = () => resolve();
      });
      await video.play();

      setStatus('稼働中');
      btnStop.disabled = false;
      btnStart.disabled = true;

      await listDevices();
      if (deviceId) selDevice.value = deviceId;

      renderLoop();
    }

    btnStart.addEventListener('click', async () => {
      try {
        setStatus('起動中...');
        await startCamera(selDevice.value || null);
      } catch (e) {
        setStatus('開始失敗');
        setError(e);
        stopStream();
      }
    });

    btnStop.addEventListener('click', () => stopStream());

    selDevice.addEventListener('change', async () => {
      if (!stream) return;
      try {
        setStatus('切替中...');
        await startCamera(selDevice.value);
      } catch (e) {
        setStatus('切替失敗');
        setError(e);
        stopStream();
      }
    });

    (async () => {
      try { await listDevices(); } catch (e) { /* ignore */ }
    })();
  </script>
</body>
</html>
